local teamSide = -1
local spikeMode = 1


local player = game.Players.LocalPlayer
local Players = game:GetService("Players")
local HRP = player.Character.HumanoidRootPart
local UIS = game:GetService("UserInputService")

local partNameToCheck = "Ball"
local currentBall
local balls = {}
local time = 0.3
local deepCut = math.rad(74)

local indicatorFolder = Instance.new("Folder", game:GetService("Workspace"))
indicatorFolder.Name = "indic"
local indicators = game.Workspace.indic

local indicatorFolder2 = Instance.new("Folder", game:GetService("Workspace"))
indicatorFolder2.Name = "indic2"
local indicators2 = game.Workspace.indic2

local transparency = 1
local ysize = 2

local filterTable = {}
local indicatorsArray = {}
local playersArray = {}
local possibleSpots = {}
local farthestPart = nil
local farthestDistance = nil

local ovParams = OverlapParams.new()
ovParams.FilterDescendantsInstances = {indicators}
ovParams.CollisionGroup = "Default"
ovParams.FilterType = Enum.RaycastFilterType.Whitelist
ovParams.MaxParts = 0

local ovParams2 = OverlapParams.new()
ovParams2.FilterDescendantsInstances = {indicators2}
ovParams2.CollisionGroup = "Default"
ovParams2.FilterType = Enum.RaycastFilterType.Whitelist
ovParams2.MaxParts = 0




-- Walls Creation
local function wallsCreation()
	local wallsFolder = Instance.new("Folder", game:GetService("Workspace"))
    wallsFolder.Name = "Walls"
    local wallTransparency = 1

    local part1 = Instance.new("Part", game.Workspace.Walls)
    part1.Name = "wall"
    part1.Anchored = true
    part1.CanCollide = false
    part1.Shape = Enum.PartType.Block
    part1.BrickColor = BrickColor.new(21)
    part1.Material = Enum.Material.Neon
    part1.Transparency = wallTransparency
    part1.Size = Vector3.new(1, 300, 300)
    part1.Position = Vector3.new(90, 0, 0)

    local part2 = Instance.new("Part", game.Workspace.Walls)
    part2.Name = "wall"
    part2.Anchored = true
    part2.CanCollide = false
    part2.Shape = Enum.PartType.Block
    part2.BrickColor = BrickColor.new(21)
    part2.Material = Enum.Material.Neon
    part2.Transparency = wallTransparency
    part2.Size = Vector3.new(180, 300, 1)
    part2.Position = Vector3.new(0, 0, 150)

    local part3 = Instance.new("Part", game.Workspace.Walls)
    part3.Name = "wall"
    part3.Anchored = true
    part3.CanCollide = false
    part3.Shape = Enum.PartType.Block
    part3.BrickColor = BrickColor.new(21)
    part3.Material = Enum.Material.Neon
    part3.Transparency = wallTransparency
    part3.Size = Vector3.new(1, 300, 300)
    part3.Position = Vector3.new(-90, 0, 0)

    local part4 = Instance.new("Part", game.Workspace.Walls)
    part4.Name = "wall"
    part4.Anchored = true
    part4.CanCollide = false
    part4.Shape = Enum.PartType.Block
    part4.BrickColor = BrickColor.new(21)
    part4.Material = Enum.Material.Neon
    part4.Transparency = wallTransparency
    part4.Size = Vector3.new(180, 300, 1)
    part4.Position = Vector3.new(0, 0, -150)
end

wallsCreation()

local walls = game.Workspace:FindFirstChild("Walls")




-- Side Picker (Auto Block)
function sidePicker()
    for i = 0, 24, 2 do
        for j = 1, 47, 2 do
            local part1 = Instance.new("Part", indicators)
            part1.Name = "indicator"
            part1.Anchored = true
            part1.CanCollide = false
            part1.Shape = Enum.PartType.Ball
            part1.BrickColor = BrickColor.new(21)
            part1.Material = Enum.Material.Neon
            part1.Transparency = transparency
            part1.Size = Vector3.new(2, ysize, 2)
            part1.Position = Vector3.new(i, 0, j)
            table.insert(indicatorsArray, part1)

            local part2 = Instance.new("Part", indicators)
            part2.Name = "indicator"
            part2.Anchored = true
            part2.CanCollide = false
            part2.Shape = Enum.PartType.Ball
            part2.BrickColor = BrickColor.new(21)
            part2.Material = Enum.Material.Neon
            part2.Transparency = transparency
            part2.Size = Vector3.new(2, ysize, 2)
            part2.Position = Vector3.new(-i, 0, j)
            table.insert(indicatorsArray, part2)
        end
    end
    for i = 0, 24, 2 do
        for j = -1, -47, -2 do
            local part3 = Instance.new("Part", indicators2)
            part3.Name = "indicator"
            part3.Anchored = true
            part3.CanCollide = false
            part3.Shape = Enum.PartType.Ball
            part3.BrickColor = BrickColor.new(21)
            part3.Material = Enum.Material.Neon
            part3.Transparency = transparency
            part3.Size = Vector3.new(2, ysize, 2)
            part3.Position = Vector3.new(i, 0, j)
            table.insert(indicatorsArray, part3)

            local part4 = Instance.new("Part", indicators2)
            part4.Name = "indicator"
            part4.Anchored = true
            part4.CanCollide = false
            part4.Shape = Enum.PartType.Ball
            part4.BrickColor = BrickColor.new(21)
            part4.Material = Enum.Material.Neon
            part4.Transparency = transparency
            part4.Size = Vector3.new(2, ysize, 2)
            part4.Position = Vector3.new(-i, 0, j)
            table.insert(indicatorsArray, part4)
        end
    end
end

do
    sidePicker()
end



-- Luka Doncic (Ball Handlers)
local function onPartAdded(part)
    -- Check if the added part matches the name we are looking for
    if part.Name == partNameToCheck then
        --currentBall = part
        table.insert(balls, part)
    end
end

local function onPartRemoved(part)
    -- Check if the added part matches the name we are looking for
    if part.Name == partNameToCheck then
        --currentBall = part
        local partToRemove = part
        for i, v in ipairs(balls) do
            if v == partToRemove then
                table.remove(balls, i)
                break
            end
        end
    end
end

local function ballDistance(point1, point2)
    local dx = point2.X - point1.X
    local dz = point2.Z - point1.Z
    return math.sqrt(dx * dx + dz * dz)
end

local function setCurrentBall()
    local closestBallDistance
    local closestBall
    if #balls ~= 0 then 
        for i, v in ipairs(balls) do
            if #balls == 1 then
                closestBall = v
            elseif closestBall == nil then
                closestBall = v
                closestBallDistance = ballDistance(HRP.Position, closestBall.Position.Value)
            elseif closestBall ~= nil and closestBallDistance > ballDistance(HRP.Position, v.Position.Value) then 
                closestBall = v
                closestBallDistance = ballDistance(HRP.Position, v.Position.Value) 
            end
        end
    end
    if closestBall then
        currentBall = closestBall
    end
end

local function predictBallPosition()
    local initialPosition = currentBall.Position.Value
    local initialVelocity = currentBall.Velocity.Value
    local velocityX = initialVelocity.X 
    local velocityZ = initialVelocity.Z
    local newPositionX = initialPosition.X + (velocityX * time)
    local newPositionZ = initialPosition.Z + (velocityZ * time)
    return Vector3.new(newPositionX, initialPosition.Y, newPositionz)
end 

game.Workspace.ChildAdded:Connect(onPartAdded)
game.Workspace.ChildRemoved:Connect(onPartRemoved)



-- Jump Direction for Glide Spike
local function jumpTowardsTarget(player, targetPosition)
    -- Calculate the direction from player's current position to the target position
    local direction = (targetPosition - player.Character.HumanoidRootPart.Position).unit

    -- Set the jump power (adjust this value as needed)
    local jumpPower = 38

    -- Calculate the jump velocity based on direction and jump power
    local jumpVelocity = direction * jumpPower

    -- Apply the jump velocity to the player's HumanoidRootPart
    player.Character.HumanoidRootPart.Velocity = Vector3.new(jumpVelocity.X, 0, jumpVelocity.Z)
end

local function jumpTowardsTarget2(player, targetPosition)
    -- Calculate the direction from player's current position to the target position
    local direction = (targetPosition - player.Character.HumanoidRootPart.Position).unit

    -- Set the jump power (adjust this value as needed)
    local jumpPower = 30

    -- Calculate the jump velocity based on direction and jump power
    local jumpVelocity = direction * jumpPower

    -- Apply the jump velocity to the player's HumanoidRootPart
    player.Character.HumanoidRootPart.Velocity = Vector3.new(jumpVelocity.X, 0, jumpVelocity.Z)
end




-- Input Handler
UIS.InputBegan:Connect(function(input, gameProcessedEvent) --Best way to do this
    if gameProcessedEvent then
        return
    end
    if input.KeyCode == Enum.KeyCode.V then
        if teamSide == 1 then
            ididathing(ovParams)
        elseif teamSide == -1 then
            ididathing(ovParams2)
        end
    elseif input.KeyCode == Enum.KeyCode.KeypadMultiply then
        teamSide *= -1
    elseif input.KeyCode == Enum.KeyCode.KeypadDivide then
        deepCut *= -1
    elseif input.KeyCode == Enum.KeyCode.Two then
        deepCut *= -1
    elseif input.KeyCode == Enum.KeyCode.R then
        rebound()
    elseif input.KeyCode == Enum.KeyCode.F4 then
        if teamSide == 1 then 
            glideSpike(ovParams)
        elseif teamSide == -1 then
            glideSpike(ovParams2)
        end
    elseif input.KeyCode == Enum.KeyCode.F3 then
        local targPosition
        if teamSide == -1 then
            HRP.Tilt.D = 350
            HRP.Tilt.P = 2700
            player.Character.Humanoid.AutoRotate = false
            HRP.CFrame = CFrame.lookAt(HRP.Position, Vector3.new(HRP.Position.X, HRP.Position.Y, 0))
            if HRP.Position.X > 0 then
                player.Character.Humanoid.HipHeight = 3.5
                HRP.CFrame *= CFrame.Angles(0, deepCut, 0)
                keypress(0x63)
                setCurrentBall()
                targPosition = Vector3.new(currentBall.Position.Value.X, 0, 0)
                jumpTowardsTarget(player, targPosition)
                keypress(0x20)
                wait(0.2)
                keypress(0x77)
                wait(0.4)
                keyrelease(0x20)
                keyrelease(0x77)
                keyrelease(0x63)
                player.Character.Humanoid.HipHeight = 2
            else
                player.Character.Humanoid.HipHeight = 3.5
                HRP.CFrame *= CFrame.Angles(0, deepCut * -1, 0)
                keypress(0x63)
                setCurrentBall()
                targPosition = Vector3.new(currentBall.Position.Value.X, 0, 0)
                jumpTowardsTarget(player, targPosition)
                keypress(0x20)
                wait(0.2)
                keypress(0x77)
                wait(0.4)
                keyrelease(0x20)
                keyrelease(0x77)
                keyrelease(0x63)
                player.Character.Humanoid.HipHeight = 2
            end
        else
            HRP.Tilt.D = 350
            HRP.Tilt.P = 2700
            player.Character.Humanoid.AutoRotate = false
            HRP.CFrame = CFrame.lookAt(HRP.Position, Vector3.new(HRP.Position.X, HRP.Position.Y, 0))
            if HRP.Position.X < 0 then
                player.Character.Humanoid.HipHeight = 3.5
                HRP.CFrame *= CFrame.Angles(0, deepCut, 0)
                keypress(0x63)
                setCurrentBall()
                targPosition = Vector3.new(currentBall.Position.Value.X, 0, 0)
                jumpTowardsTarget(player, targPosition)
                keypress(0x20)
                wait(0.2)
                keypress(0x77)
                wait(0.4)
                keyrelease(0x20)
                keyrelease(0x77)
                keyrelease(0x63)
                player.Character.Humanoid.HipHeight = 2
            else
                player.Character.Humanoid.HipHeight = 3.5
                HRP.CFrame *= CFrame.Angles(0, deepCut * -1, 0)
                keypress(0x63)
                setCurrentBall()
                targPosition = Vector3.new(currentBall.Position.Value.X, 0, 0)
                jumpTowardsTarget(player, targPosition)
                keypress(0x20)
                wait(0.2)
                keypress(0x77)
                wait(0.4)
                keyrelease(0x20)
                keyrelease(0x77)
                keyrelease(0x63)
                player.Character.Humanoid.HipHeight = 2
            end
        end
        HRP.Tilt.D = 500
        HRP.Tilt.P = 3000
    end
end)




-- Auto Spike
function ididathing(tempParams)
    -- Spike Distance
    setCurrentBall()
    local longin = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 48 + tonumber(math.abs(HRP.Position.Z)), tempParams)
    local longout = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 45 + tonumber(math.abs(HRP.Position.Z)), tempParams)

    local newmidlongin = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 44.5, tempParams)
    local newmidlongout = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 42.5, tempParams)

    local midlongin = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 42, tempParams)
    local midlongout = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 39, tempParams)

    local newmidin = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 38, tempParams)
    local newmidout = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 36, tempParams)

    local midin = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 35, tempParams)
    local midout = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 32, tempParams)

    local shortmidin2 = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 31.5, tempParams)
    local shortmidout2 = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 29, tempParams)

    local shortmidin1 = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 28, tempParams)
    local shortmidout1 = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 25, tempParams)

    local shortin = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 24, tempParams)
    local shortout = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 19, tempParams)
    local bumpnetNetout = workspace:GetPartBoundsInBox(CFrame.new(0, 0, 0), Vector3.new(48, 5, 1), tempParams)
    local netout = workspace:GetPartBoundsInBox(CFrame.new(0, 0, 0), Vector3.new(48, 5, (2 * tonumber(math.abs(HRP.Position.Z))) - 1), tempParams)
    for i, v in pairs(longin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(longout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(newmidlongin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(newmidlongout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(midlongin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(midlongout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(newmidin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(newmidout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(midin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(midout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(shortmidin2) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(shortmidout2) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(shortmidin1) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(shortmidout1) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(shortin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(shortout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(netout) do
        v.BrickColor = BrickColor.new(21)
    end
    if currentBall and currentBall.Position.Value.Z > 0.4 and currentBall.Position.Value.Z < -0.4 then
        for i, v in pairs(bumpnetNetout) do
            v.BrickColor = BrickColor.new(21)
        end
    end
    for i, v in pairs(longin) do
        if v.BrickColor == BrickColor.new(37) then
            table.insert(possibleSpots, v)
            v.Transparency = 0.8
        end
    end

    local tempArray = {}
    local tempPlayerArray = {}
    for i, v in ipairs(possibleSpots) do
        table.insert(tempArray, v)
    end
    for i, v in ipairs(playersArray) do
        table.insert(tempPlayerArray, v)
    end
    local finalArray, finalplayerArray = antiBlock(tempArray, tempPlayerArray)
    farthestFinder(finalArray, finalplayerArray) -- Find Farthest Part
    farthestPart.BrickColor = BrickColor.new(1)
    farthestPart.Transparency = 0
    
    -- Tilt Handler
    local tilt
    if findDistance(farthestPart, player) < 26 then
        tilt = true
    elseif findDistance(farthestPart, player) < 29 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 1400
    elseif findDistance(farthestPart, player) < 32 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 1100
    elseif findDistance(farthestPart, player) < 36 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 800
    elseif findDistance(farthestPart, player) < 38 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 550
    elseif findDistance(farthestPart, player) < 42.5 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 300
    elseif findDistance(farthestPart, player) < 44 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 150
    end

    -- Spike Inputs
    keypress(0x57)
    keypress(0x41)
    keypress(0x53)
    keypress(0x44)
    keypress(0x43)
    wait(0.01)
    HRP.CFrame = CFrame.lookAt(HRP.Position, Vector3.new(farthestPart.Position.X, HRP.Position.Y, farthestPart.Position.Z)) -- AIM
    keypress(0x20)  -- JUMP
    wait(0.01)
    keyrelease(0x57)
    keyrelease(0x41)
    keyrelease(0x53)
    keyrelease(0x44)
    keyrelease(0x43)
    player.Character.Humanoid.AutoRotate = false
    if tilt then  -- FORWARD TILT
        keypress(0x57)
        wait(0.05)
        keyrelease(0x57)
    end

    -- Cleanup
    table.clear(possibleSpots)
    keyrelease(0x20)
    player.Character.Humanoid.AutoRotate = true
    for i, v in pairs(longin) do
        v.BrickColor = BrickColor.new(21)
        v.Transparency = 1
    end
    farthestPart.Transparency = 1
    farthestPart = nil
    local farthestDistance = nil
    longin = {}
    longout = {}
    shortin = {}
    shortout = {}
    task.wait(1)
    HRP.Tilt.D = 500
    HRP.Tilt.P = 3000
end


-- Glide AutoSpike
function glideSpike(tempParams)
    local ballPrediction
    setCurrentBall()
    ballPrediction = predictBallPosition()
    local longin = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 48 + tonumber(math.abs(currentBall.Position.Value.Z)), tempParams)
    local longout = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 45 + tonumber(math.abs(currentBall.Position.Value.Z)), tempParams)

    local newmidlongin = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 44.5, tempParams)
    local newmidlongout = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 42.5, tempParams)

    local midlongin = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 42, tempParams)
    local midlongout = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 39, tempParams)

    local newmidin = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 38, tempParams)
    local newmidout = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 36, tempParams)

    local midin = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 35, tempParams)
    local midout = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 32, tempParams)

    local shortmidin2 = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 31.5, tempParams)
    local shortmidout2 = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 29, tempParams)

    local shortmidin1 = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 28, tempParams)
    local shortmidout1 = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 25, tempParams)

    local shortin = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 24, tempParams)
    local shortout = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 19, tempParams)
    local bumpnetNetout = workspace:GetPartBoundsInBox(CFrame.new(0, 0, 0), Vector3.new(48, 5, 1), tempParams)
    local netout = workspace:GetPartBoundsInBox(CFrame.new(0, 0, 0), Vector3.new(48, 5, (2 * tonumber(math.abs(currentBall.Position.Value.Z))) - 1), tempParams)
    for i, v in pairs(longin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(longout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(newmidlongin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(newmidlongout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(midlongin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(midlongout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(newmidin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(newmidout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(midin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(midout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(shortmidin2) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(shortmidout2) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(shortmidin1) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(shortmidout1) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(shortin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(shortout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(netout) do
        v.BrickColor = BrickColor.new(21)
    end
    if currentBall and currentBall.Position.Value.Z > 0.4 and currentBall.Position.Value.Z < -0.4 then
        for i, v in pairs(bumpnetNetout) do
            v.BrickColor = BrickColor.new(21)
        end
    end
    for i, v in pairs(longin) do
        if v.BrickColor == BrickColor.new(37) then
            table.insert(possibleSpots, v)
            v.Transparency = 0.8
        end
    end

    local tempArray = {}
    local tempPlayerArray = {}
    for i, v in ipairs(possibleSpots) do
        table.insert(tempArray, v)
    end
    for i, v in ipairs(playersArray) do
        table.insert(tempPlayerArray, v)
    end
    local finalArray, finalplayerArray = antiBlock2(tempArray, currentBall, tempPlayerArray)
    farthestFinder(finalArray, finalplayerArray) -- Find Farthest Part
    farthestPart.BrickColor = BrickColor.new(1)
    farthestPart.Transparency = 0
    
    -- Tilt Handler
    local tilt
    if findDistance2(farthestPart, currentBall) < 26 then
        tilt = true
    elseif findDistance2(farthestPart, currentBall) < 29 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 1400
    elseif findDistance2(farthestPart, currentBall) < 32 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 1100
    elseif findDistance2(farthestPart, currentBall) < 36 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 800
    elseif findDistance2(farthestPart, currentBall) < 38 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 550
    elseif findDistance2(farthestPart, currentBall) < 42.5 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 300
    elseif findDistance2(farthestPart, currentBall) < 44 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 150
    end

    -- Spike Inputs
    keypress(0x43)
    wait(0.01)
    --HRP.CFrame = CFrame.lookAt(HRP.Position, Vector3.new(farthestPart.Position.X, HRP.Position.Y, farthestPart.Position.Z)) -- AIM
    local direction = (Vector3.new(farthestPart.Position.X, 0, farthestPart.Position.Z) - (Vector3.new(currentBall.Position.Value.X, 0, currentBall.Position.Value.Z))).unit
    local targPosition = Vector3.new(currentBall.Position.Value.X, HRP.Position.Y, currentBall.Position.Value.Z)
    HRP.CFrame = CFrame.lookAlong(HRP.Position, direction)
    jumpTowardsTarget2(player, targPosition)
    keypress(0x20)  -- JUMP
    wait(0.01)
    keyrelease(0x43)
    player.Character.Humanoid.AutoRotate = false
    if tilt then  -- FORWARD TILT
        keypress(0x57)
        wait(0.05)
        keyrelease(0x57)
    end

    -- Cleanup
    table.clear(possibleSpots)
    keyrelease(0x20)
    player.Character.Humanoid.AutoRotate = true
    for i, v in pairs(longin) do
        v.BrickColor = BrickColor.new(21)
        v.Transparency = 1
    end
    farthestPart.Transparency = 1
    farthestPart = nil
    local farthestDistance = nil
    longin = {}
    longout = {}
    shortin = {}
    shortout = {}
    task.wait(1)
    HRP.Tilt.D = 500
    HRP.Tilt.P = 3000
end




-- Array Handling
do
    playersArray = Players:GetChildren()
end

Players.ChildAdded:Connect(function(v)
    table.insert(playersArray, v)
end)

Players.PlayerRemoving:Connect(function(v)
    local found = table.find(playersArray, v)
    if found then
        table.remove(playersArray, found)
    end
end)





-- Find Distance Between Spot and Player
function findDistance(spot, plr)
    --print(math.sqrt(((plr.Character.HumanoidRootPart.Position.X - spot.Position.X)^2) + ((plr.Character.HumanoidRootPart.Position.Z - spot.Position.Z)^2)))
    return math.sqrt(((plr.Character.HumanoidRootPart.Position.X - spot.Position.X)^2) + ((plr.Character.HumanoidRootPart.Position.Z - spot.Position.Z)^2))
end

function findDistance2(spot, plr)
    --print(math.sqrt(((plr.Character.HumanoidRootPart.Position.X - spot.Position.X)^2) + ((plr.Character.HumanoidRootPart.Position.Z - spot.Position.Z)^2)))
    return math.sqrt(((plr.Position.Value.X - spot.Position.X)^2) + ((plr.Position.Value.Z - spot.Position.Z)^2))
end



-- Find Furthest Spot From Player
function farthestFinder(spods, playas)
    farthestDistance = nil
    for _, v in pairs(spods) do -- for every spot
        local closestDistance = nil -- the closest distance between the closest spot and player
        for _, u in pairs(playas) do
            if u.TeamColor ~= player.TeamColor and u.TeamColor ~= BrickColor.new("White")then
                local currentDistance = findDistance(v, u) -- Finds the current distance between the current spot and current player

                -- If there is no closestDistance yet OR the distance between the current spot and player is smaller than the previous closestDistance
                if closestDistance == nil or currentDistance < closestDistance then
                    closestDistance = currentDistance -- Sets the new smallest distance to a player
                end
            end
        end
        if closestDistance then
            if farthestDistance == nil or closestDistance > farthestDistance then -- if the distance to the closest player is > than the previous farthestDistance
                farthestDistance = closestDistance -- set new farthestDistance
                farthestPart = v -- sets new farthestPart
            end
        end
    end
end




-- Rebound Script
function rebound()
    local rcParams = RaycastParams.new()
    rcParams.FilterDescendantsInstances = {filterTable}
    rcParams.FilterType = Enum.RaycastFilterType.Whitelist
    local origin = Vector3.new(HRP.Position.X, HRP.Position.Y, HRP.Position.Z)
    local direction = HRP.CFrame.LookVector * 15
    local rcResult = workspace:Raycast(origin, direction, rcParams)
    if rcResult then
        keypress(0x78)
        wait(0.001)
        keyrelease(0x78)
    end
end


-- Anti Block 
function isJumping(v)
    -- Get the player's character
    local character = v.Character
    if character then
        -- Get the Humanoid
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            -- Check if the Humanoid is currently jumping
            return humanoid.FloorMaterial == Enum.Material.Air
        end
    end
    return false
end


function findJumpingPlayers()
    local jumpingPlayers = {}
    for _, v in ipairs(Players:GetPlayers()) do
        if v.TeamColor ~= player.TeamColor then
            if isJumping(v) then
                table.insert(jumpingPlayers, v)
            end
        end
    end
    return jumpingPlayers
end

function findIgnoreablePlayers()
    local ignoreablePlayers = {}
    for _, v in ipairs(Players:GetPlayers()) do
        if v.TeamColor ~= player.TeamColor then
            if isJumping(v) then
                if v.Character.HumanoidRootPart.Position.Y < 6.6 and v.Character.HumanoidRootPart.Velocity.Y < 0 then
                    table.insert(ignoreablePlayers, v)
                end
            end
        end
    end
    return ignoreablePlayers
end

--[[function findJumpers()
    local jumpingPlayers = findJumpingPlayers()
    for _, v in ipairs(jumpingPlayers) do
        print(player.Name .. " is jumping.")
    end
end]]--

function calculateArea(x1, z1, x2, z2, x3, z3)
	return math.abs((x1*(z2-z3) + x2*(z3-z1) + x3*(z1-z2)) / 2.0)
end

function isInsideTriangle(x1, z1, x2, z2, x3, z3, x, z)
	-- Calculate the total area of the triangle
	local totalArea = calculateArea(x1, z1, x2, z2, x3, z3)

	-- Calculate the area of three sub-triangles formed by the point and the triangle vertices
	local area1 = calculateArea(x, z, x2, z2, x3, z3)
	local area2 = calculateArea(x1, z1, x, z, x3, z3)
	local area3 = calculateArea(x1, z1, x2, z2, x, z)

	-- If the sum of the areas of the sub-triangles equals the total area, the point is inside the triangle
	return (totalArea == area1 + area2 + area3)
end

function castray(origin, direction)
    --print(walls)
	local rayDirection = CFrame.lookAt(HRP.Position, Vector3.new(direction.Position.X, origin.Y, direction.Position.Z))
    --print(origin, "OG")
    --print(direction.Position, "DP")
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {walls}
	raycastParams.FilterType = Enum.RaycastFilterType.Include
	raycastParams.IgnoreWater = true

	local raycastResult = workspace:Raycast(HRP.Position, rayDirection.LookVector * 600, raycastParams)
    if raycastResult == nil then
        print("ITS NIL FOR SOME REASON")
    else 
        print(raycastResult.Position, "RP")
    end
    return raycastResult.Position
end

function antiBlock(tempArray, tempPlayerArray) -- tempArray = position of possible spots
    local finalArray = {}
    local finalplayerArray = {}
    local jumpingPlayers = findJumpingPlayers()
    local ignoreablePlayers = findIgnoreablePlayers()
    if #jumpingPlayers ~= 0 then 
        for _, v in ipairs(jumpingPlayers) do
            local blockHitboxCF = v.Character.BlockHitbox.CFrame
            local size = v.Character.BlockHitbox.Size

            local directLeft = (blockHitboxCF - blockHitboxCF.RightVector * size.X/2)
            local backLeft = (directLeft - blockHitboxCF.LookVector * size.X/2)
            local frontLeft = (directLeft + blockHitboxCF.LookVector * size.X/2)

            local directRight = (blockHitboxCF + blockHitboxCF.RightVector * size.X/2)
            local backRight = (directRight - blockHitboxCF.LookVector * size.X/2)
            local frontRight = (directRight + blockHitboxCF.LookVector * size.X/2)

            local t1 = HRP.Position
            local t2 = castray(HRP.Position, backLeft)
            local t3 = castray(HRP.Position, frontRight)
            local t4 = castray(HRP.Position, backRight)
            local t5 = castray(HRP.Position, frontLeft)
            local t6
            for _, u in ipairs(tempArray) do
                t6 = u.Position
                --print(t6.. "t6")
                if not isInsideTriangle(t1.X, t1.Z, t2.X, t2.Z, t3.X, t3.Z, t6.X, t6.Z) and not isInsideTriangle(t1.X, t1.Z, t4.X, t4.Z, t5.X, t5.Z, t6.X, t6.Z) then
                    table.insert(finalArray, u)
                else
                    u.BrickColor = BrickColor.new(21)
                end
            end
            for i, u in ipairs(tempPlayerArray) do
                if u ~= v then
                    table.insert(finalplayerArray, u)
                end
            end
        end
        for i = #finalplayerArray, 1, -1 do
            local playerToCheck = finalplayerArray[i]
            if table.find(ignoreablePlayers, playerToCheck) then
                table.remove(finalplayerArray, i)
            end
        end
        return finalArray, finalplayerArray
    else
        return tempArray, tempPlayerArray
    end
end




function castray2(origin, direction)
    --print(walls)
	local rayDirection = CFrame.lookAt(origin, Vector3.new(direction.Position.X, origin.Y, direction.Position.Z))
    --print(origin, "OG")
    --print(direction.Position, "DP")
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {walls}
	raycastParams.FilterType = Enum.RaycastFilterType.Include
	raycastParams.IgnoreWater = true

	local raycastResult = workspace:Raycast(origin, rayDirection.LookVector * 600, raycastParams)
    if raycastResult == nil then
        print("ITS NIL FOR SOME REASON")
    else 
        print(raycastResult.Position, "RP")
    end
    return raycastResult.Position
end

function antiBlock2(tempArray, origin, tempPlayerArray) -- tempArray = position of possible spots
    local finalArray = {}
    local finalplayerArray = {}
    local jumpingPlayers = findJumpingPlayers()
    local ignoreablePlayers = findIgnoreablePlayers()
    if #jumpingPlayers ~= 0 then 
        for _, v in ipairs(jumpingPlayers) do
            local blockHitboxCF = v.Character.BlockHitbox.CFrame
            local size = v.Character.BlockHitbox.Size
            local directLeft = (blockHitboxCF - blockHitboxCF.RightVector * size.X/2)
            local backLeft = (directLeft - blockHitboxCF.LookVector * size.X/2)
            local frontLeft = (directLeft + blockHitboxCF.LookVector * size.X/2)

            local directRight = (blockHitboxCF + blockHitboxCF.RightVector * size.X/2)
            local backRight = (directRight - blockHitboxCF.LookVector * size.X/2)
            local frontRight = (directRight + blockHitboxCF.LookVector * size.X/2)
            local t1 = origin.Position.Value
            local t2 = castray2(origin.Position.Value, backLeft)
            local t3 = castray2(origin.Position.Value, frontRight)
            local t4 = castray2(origin.Position.Value, backRight)
            local t5 = castray2(origin.Position.Value, frontLeft)
            local t6
            for _, u in ipairs(tempArray) do
                t6 = u.Position
                --print(t6.. "t6")
                if not isInsideTriangle(t1.X, t1.Z, t2.X, t2.Z, t3.X, t3.Z, t6.X, t6.Z) and not isInsideTriangle(t1.X, t1.Z, t4.X, t4.Z, t5.X, t5.Z, t6.X, t6.Z) then
                    table.insert(finalArray, u)
                else
                    u.BrickColor = BrickColor.new(21)
                end
            end
            for i, u in ipairs(tempPlayerArray) do
                if u ~= v then
                    table.insert(finalplayerArray, u)
                end
            end
        end
        for i = #finalplayerArray, 1, -1 do
            local playerToCheck = finalplayerArray[i]
            if table.find(ignoreablePlayers, playerToCheck) then
                table.remove(finalplayerArray, i)
            end
        end
	return finalArray, finalplayerArray
    else
        return tempArray, tempPlayerArray
    end
end
