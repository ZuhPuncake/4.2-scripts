local teamSide = -1
local spikeMode = 1


local player = game.Players.LocalPlayer
local Players = game:GetService("Players")
local HRP = player.Character.HumanoidRootPart
local UIS = game:GetService("UserInputService")

local partNameToCheck = "Ball"
local currentBall
local balls = {}
local Balls = {}
local time = 0.3
local deepCut = math.rad(74)
local netTop = {}

local indicatorFolder = Instance.new("Folder", game:GetService("Workspace"))
indicatorFolder.Name = "indic"
local indicators = game.Workspace.indic

local indicatorFolder2 = Instance.new("Folder", game:GetService("Workspace"))
indicatorFolder2.Name = "indic2"
local indicators2 = game.Workspace.indic2

local transparency = 1
local ysize = 2

local filterTable = {}
local indicatorsArray = {}
local playersArray = {}
local possibleSpots = {}
local farthestPart = nil
local farthestDistance = nil

local ovParams = OverlapParams.new()
ovParams.FilterDescendantsInstances = {indicators}
ovParams.CollisionGroup = "Default"
ovParams.FilterType = Enum.RaycastFilterType.Whitelist
ovParams.MaxParts = 0

local ovParams2 = OverlapParams.new()
ovParams2.FilterDescendantsInstances = {indicators2}
ovParams2.CollisionGroup = "Default"
ovParams2.FilterType = Enum.RaycastFilterType.Whitelist
ovParams2.MaxParts = 0

for _, v in ipairs(game:GetService("Workspace"):GetChildren()) do
    if v.Name == "NetTop" and v:IsA("BasePart") then
        table.insert(netTop, v)
    elseif v.Name == "Net" and v:IsA("BasePart") then
        table.insert(netTop, v)
    end
end

local netParams = RaycastParams.new()
netParams.FilterType = Enum.RaycastFilterType.Whitelist
netParams.FilterDescendantsInstances = netTop
netParams.IgnoreWater = true




-- Walls Creation
local function wallsCreation()
	local wallsFolder = Instance.new("Folder", game:GetService("Workspace"))
    wallsFolder.Name = "Walls"
    local wallTransparency = 1

    local part1 = Instance.new("Part", game.Workspace.Walls)
    part1.Name = "wall"
    part1.Anchored = true
    part1.CanCollide = false
    part1.Shape = Enum.PartType.Block
    part1.BrickColor = BrickColor.new(21)
    part1.Material = Enum.Material.Neon
    part1.Transparency = wallTransparency
    part1.Size = Vector3.new(1, 300, 300)
    part1.Position = Vector3.new(90, 0, 0)

    local part2 = Instance.new("Part", game.Workspace.Walls)
    part2.Name = "wall"
    part2.Anchored = true
    part2.CanCollide = false
    part2.Shape = Enum.PartType.Block
    part2.BrickColor = BrickColor.new(21)
    part2.Material = Enum.Material.Neon
    part2.Transparency = wallTransparency
    part2.Size = Vector3.new(180, 300, 1)
    part2.Position = Vector3.new(0, 0, 150)

    local part3 = Instance.new("Part", game.Workspace.Walls)
    part3.Name = "wall"
    part3.Anchored = true
    part3.CanCollide = false
    part3.Shape = Enum.PartType.Block
    part3.BrickColor = BrickColor.new(21)
    part3.Material = Enum.Material.Neon
    part3.Transparency = wallTransparency
    part3.Size = Vector3.new(1, 300, 300)
    part3.Position = Vector3.new(-90, 0, 0)

    local part4 = Instance.new("Part", game.Workspace.Walls)
    part4.Name = "wall"
    part4.Anchored = true
    part4.CanCollide = false
    part4.Shape = Enum.PartType.Block
    part4.BrickColor = BrickColor.new(21)
    part4.Material = Enum.Material.Neon
    part4.Transparency = wallTransparency
    part4.Size = Vector3.new(180, 300, 1)
    part4.Position = Vector3.new(0, 0, -150)
end

wallsCreation()

local walls = game.Workspace:FindFirstChild("Walls")




-- Side Picker (Auto Block)
function sidePicker()
    for i = 0, 24, 2 do
        for j = 1, 47, 2 do
            local part1 = Instance.new("Part", indicators)
            part1.Name = "indicator"
            part1.Anchored = true
            part1.CanCollide = false
            part1.Shape = Enum.PartType.Ball
            part1.BrickColor = BrickColor.new(21)
            part1.Material = Enum.Material.Neon
            part1.Transparency = transparency
            part1.Size = Vector3.new(2, ysize, 2)
            part1.Position = Vector3.new(i, 0, j)
            table.insert(indicatorsArray, part1)

            local part2 = Instance.new("Part", indicators)
            part2.Name = "indicator"
            part2.Anchored = true
            part2.CanCollide = false
            part2.Shape = Enum.PartType.Ball
            part2.BrickColor = BrickColor.new(21)
            part2.Material = Enum.Material.Neon
            part2.Transparency = transparency
            part2.Size = Vector3.new(2, ysize, 2)
            part2.Position = Vector3.new(-i, 0, j)
            table.insert(indicatorsArray, part2)
        end
    end
    for i = 0, 24, 2 do
        for j = -1, -47, -2 do
            local part3 = Instance.new("Part", indicators2)
            part3.Name = "indicator"
            part3.Anchored = true
            part3.CanCollide = false
            part3.Shape = Enum.PartType.Ball
            part3.BrickColor = BrickColor.new(21)
            part3.Material = Enum.Material.Neon
            part3.Transparency = transparency
            part3.Size = Vector3.new(2, ysize, 2)
            part3.Position = Vector3.new(i, 0, j)
            table.insert(indicatorsArray, part3)

            local part4 = Instance.new("Part", indicators2)
            part4.Name = "indicator"
            part4.Anchored = true
            part4.CanCollide = false
            part4.Shape = Enum.PartType.Ball
            part4.BrickColor = BrickColor.new(21)
            part4.Material = Enum.Material.Neon
            part4.Transparency = transparency
            part4.Size = Vector3.new(2, ysize, 2)
            part4.Position = Vector3.new(-i, 0, j)
            table.insert(indicatorsArray, part4)
        end
    end
end

do
    sidePicker()
end



-- Luka Doncic (Ball Handlers)
local function onPartAdded(part)
    -- Check if the added part matches the name we are looking for
    if part.Name == partNameToCheck then
        --currentBall = part
        table.insert(balls, part)
    end
end

local function onPartRemoved(part)
    -- Check if the added part matches the name we are looking for
    if part.Name == partNameToCheck then
        --currentBall = part
        local partToRemove = part
        for i, v in ipairs(balls) do
            if v == partToRemove then
                table.remove(balls, i)
                break
            end
        end
    end
end

local function ballDistance(point1, point2)
    local dx = point2.X - point1.X
    local dz = point2.Z - point1.Z
    return math.sqrt(dx * dx + dz * dz)
end

local function setCurrentBall()
    local closestBallDistance
    local closestBall
    if #balls ~= 0 then 
        for i, v in ipairs(balls) do
            if #balls == 1 then
                closestBall = v
            elseif closestBall == nil then
                closestBall = v
                closestBallDistance = ballDistance(HRP.Position, closestBall.Position.Value)
            elseif closestBall ~= nil and closestBallDistance > ballDistance(HRP.Position, v.Position.Value) then 
                closestBall = v
                closestBallDistance = ballDistance(HRP.Position, v.Position.Value) 
            end
        end
    end
    if closestBall then
        currentBall = closestBall
    end
end

local function predictBallPosition()
    local initialPosition = currentBall.Position.Value
    local initialVelocity = currentBall.Velocity.Value
    local velocityX = initialVelocity.X 
    local velocityZ = initialVelocity.Z
    local newPositionX = initialPosition.X + (velocityX * time)
    local newPositionZ = initialPosition.Z + (velocityZ * time)
    return Vector3.new(newPositionX, initialPosition.Y, newPositionz)
end 

game.Workspace.ChildAdded:Connect(onPartAdded)
game.Workspace.ChildRemoved:Connect(onPartRemoved)



-- Utility function to update the stored data for a specific Ball.
local function updateBallData(ball)
	if not Balls[ball] then return end -- If ball is nil then return end
	
	local ballRecord = Balls[ball]
	local posFolder = ball:WaitForChild("Position")
	local velFolder = ball:WaitForChild("Velocity")
	
	if posFolder and velFolder then
		local posValue = posFolder.Value
		
		local velValue = velFolder.Value
		
        -- Update stored Position/Velocity values at the moment of change
        ballRecord.Position = Vector3.new(posValue.X, posValue.Y, posValue.Z)
        ballRecord.Velocity = Vector3.new(velValue.X, velValue.Y, velValue.Z)
	end
end

-- Function to set up tracking for a newly added Ball.
local function registerBall(ball)
	-- Wait for the folders and their children to exist
	local posFolder = ball:WaitForChild("Position")
	local velFolder = ball:WaitForChild("Velocity")
	
	--posFolder:WaitForChild("X")
	--posFolder:WaitForChild("Y")
	--posFolder:WaitForChild("Z")
	--velFolder:WaitForChild("X")
	--velFolder:WaitForChild("Y")
	--velFolder:WaitForChild("Z")
	
	-- Create an entry in the Balls table
	Balls[ball] = {
		Ball = ball;
		Position = Vector3.new(); -- Will get updated below using updateBallData function
		Velocity = Vector3.new(); -- Will get updated below using updateBallData function
	}

	-- Initialize once everything has loaded
	updateBallData(ball)
	
	-- Listen for velocity changes in X or Z and update stored info
	local velX = velFolder
	local velZ = velFolder
	
	if velX then
		velX.Changed:Connect(function()
			updateBallData(ball)
		end)
	end
	
	if velZ then
		velZ.Changed:Connect(function()
			updateBallData(ball)
		end)
	end
	
	-- If the Ball is removed or parented to nil, remove it from the table
	ball.AncestryChanged:Connect(function(_, newParent)
		if not newParent then
			Balls[ball] = nil
		end
	end)
end

-- Check existing children in workspace in case some Balls are already present
for _, child in ipairs(workspace:GetChildren()) do
	if child.Name == "Ball" then
		registerBall(child)
	end
end

-- Track newly added Balls
workspace.ChildAdded:Connect(function(child)
	if child.Name == "Ball" then
		registerBall(child)
	end
end)

-- Track when a "Ball" is removed; remove from Balls table if it still exists there
workspace.ChildRemoved:Connect(function(child)
	if child.Name == "Ball" then
		Balls[child] = nil
	end
end)

-- EXAMPLE HELPER FUNCTION:
-- Finds the closest tracked Ball to a specified Vector3 position.
-- Call this from elsewhere in your scripts as needed (e.g. to aim at the nearest Ball).
local function getClosestBallToPoint(point)
	local closestBall = nil
	local closestDistance = math.huge
	
	for ballInstance, data in pairs(Balls) do
		local dist = (data.Position - point).Magnitude
		if dist < closestDistance then
			closestBall = ballInstance
			closestDistance = dist
		end
	end
	
	currentBall = closestBall
end

-- Example usage:
-- local nearest, dist = getClosestBallToPoint(Vector3.new(0, 0, 0))
-- if nearest then
--     print("Closest Ball is:", nearest, "Distance:", dist)
-- end

function glideBlock(part)
	player.Character.Humanoid.AutoRotate = false
	HRP.CFrame = CFrame.lookAt(HRP.Position, Vector3.new(HRP.Position.X, HRP.Position.Y, 0))
	keypress(0x20)
	glideBlockVelocity(Balls[part].Velocity.X, Balls[part].Position)
	wait(0.03)
	keyrelease(0x20)
	print("casted " .. math.random(1,50))
end


function glideBlockVelocity(currentXVelocity, ballPosition)
    local Xdisplacement = ballPosition.X - HRP.Position.X
    local finalVelocity
    local addon = 0
    if currentXVelocity > 22 then 
        currentXVelocity = 22
        addon = ((currentXVelocity/currentXVelocity) * 3)
    elseif currentXVelocity < -22 then
        currentXVelocity = -22
        addon = ((currentXVelocity/currentXVelocity) * 3)
    end
    finalVelocity = currentXVelocity + Xdisplacement + addon
    HRP.Velocity = Vector3.new(finalVelocity, HRP.Velocity.Y, teamSide * 20)
    addon = 0
end



-- Jump Direction for Glide Spike
local function jumpTowardsTarget(player, targetPosition)
    -- Calculate the direction from player's current position to the target position
    local direction = (targetPosition - player.Character.HumanoidRootPart.Position).unit

    -- Set the jump power (adjust this value as needed)
    local jumpPower = 38

    -- Calculate the jump velocity based on direction and jump power
    local jumpVelocity = direction * jumpPower

    -- Apply the jump velocity to the player's HumanoidRootPart
    player.Character.HumanoidRootPart.Velocity = Vector3.new(jumpVelocity.X, 0, jumpVelocity.Z)
end

local function jumpTowardsTarget2(player, targetPosition)
    -- Calculate the direction from player's current position to the target position
    local direction = (targetPosition - player.Character.HumanoidRootPart.Position).unit

    -- Set the jump power (adjust this value as needed)
    local jumpPower = 26

    -- Calculate the jump velocity based on direction and jump power
    local jumpVelocity = direction * jumpPower

    -- Apply the jump velocity to the player's HumanoidRootPart
    player.Character.HumanoidRootPart.Velocity = Vector3.new(jumpVelocity.X, 0, jumpVelocity.Z)
end



local function travelNeeded(O, S, d)       -- defender `d`
    --------------------------------------------------------------
    -- 1. Find t₀: earliest time segment is low enough to hitbox
    --------------------------------------------------------------
    local t0 = (13 - 6.25) / (13 - S.Y)
    t0 = math.clamp(t0, 0, 1)               -- stays in segment

    --------------------------------------------------------------
    -- 2. Work purely in the X‑Z plane from now on
    --------------------------------------------------------------
    local O2   = Vector2.new(O.X, O.Z)
    local S2   = Vector2.new(S.X, S.Z)
    local dir2 = S2 - O2
    local len2 = dir2:Dot(dir2)

    --------------------------------------------------------------
    -- 3. Three t-values can be closest to defender
    --------------------------------------------------------------
    local H = Vector2.new(d.Character.RecHitbox.Position.X, d.Character.RecHitbox.Position.Z)

    -- orthogonal projection of H onto OS
    local tProj = (H - O2):Dot(dir2) / len2
    tProj = math.clamp(tProj, t0, 1)

    -- evaluate horizontal gap at t0, tProj, and 1
    local best = math.huge
    for _,t in ipairs{t0, tProj, 1} do
        local P = O2 + dir2 * t
        best = math.min(best, (H - P).Magnitude)
    end

    --------------------------------------------------------------
    -- 4. How far must the defender slide?
    --------------------------------------------------------------
    return math.max(0, best - 4.25)
end

local function scoreSpot(S, defenders, O)
    local worst = math.huge         -- we want the *closest* defender
    for _,d in ipairs(defenders) do
        local gap = travelNeeded(O, S.Position, d)
        worst = math.min(worst, gap)
        if worst == 0 then break end  -- no need to continue
    end
    return worst                     -- larger = safer for spiker
end







-- Input Handler
UIS.InputBegan:Connect(function(input, gameProcessedEvent) --Best way to do this
    if gameProcessedEvent then
        return
    end
    if input.KeyCode == Enum.KeyCode.V then
        if teamSide == 1 and player.PlayerGui.HUD.Bars.Action.Text == "SPIKE" then
            ididathing(ovParams)
        elseif teamSide == -1 and player.PlayerGui.HUD.Bars.Action.Text == "SPIKE" then
            ididathing(ovParams2)
        elseif player.PlayerGui.HUD.Bars.Action.Text == "BLOCK" then
            getClosestBallToPoint(HRP.Position)
		    glideBlock(currentBall)
        end
    elseif input.KeyCode == Enum.KeyCode.KeypadMultiply then
        teamSide *= -1
    elseif input.KeyCode == Enum.KeyCode.KeypadDivide then
        deepCut *= -1
    elseif input.KeyCode == Enum.KeyCode.Two then
        deepCut *= -1
    elseif input.KeyCode == Enum.KeyCode.R then
        rebound()
    elseif input.KeyCode == Enum.KeyCode.N then
        if teamSide == 1 then 
            glideSpike(ovParams)
        elseif teamSide == -1 then
            glideSpike(ovParams2)
        end
    elseif input.KeyCode == Enum.KeyCode.F3 then
        local targPosition
        if teamSide == -1 then
            HRP.Tilt.D = 350
            HRP.Tilt.P = 2700
            player.Character.Humanoid.AutoRotate = false
            HRP.CFrame = CFrame.lookAt(HRP.Position, Vector3.new(HRP.Position.X, HRP.Position.Y, 0))
            if HRP.Position.X > 0 then
                player.Character.Humanoid.HipHeight = 3.5
                HRP.CFrame *= CFrame.Angles(0, deepCut, 0)
                keypress(0x63)
                setCurrentBall()
                targPosition = Vector3.new(currentBall.Position.Value.X, 0, 0)
                jumpTowardsTarget(player, targPosition)
                keypress(0x20)
                wait(0.2)
                keypress(0x77)
                wait(0.4)
                keyrelease(0x20)
                keyrelease(0x77)
                keyrelease(0x63)
                player.Character.Humanoid.HipHeight = 2
            else
                player.Character.Humanoid.HipHeight = 3.5
                HRP.CFrame *= CFrame.Angles(0, deepCut * -1, 0)
                keypress(0x63)
                setCurrentBall()
                targPosition = Vector3.new(currentBall.Position.Value.X, 0, 0)
                jumpTowardsTarget(player, targPosition)
                keypress(0x20)
                wait(0.2)
                keypress(0x77)
                wait(0.4)
                keyrelease(0x20)
                keyrelease(0x77)
                keyrelease(0x63)
                player.Character.Humanoid.HipHeight = 2
            end
        else
            HRP.Tilt.D = 350
            HRP.Tilt.P = 2700
            player.Character.Humanoid.AutoRotate = false
            HRP.CFrame = CFrame.lookAt(HRP.Position, Vector3.new(HRP.Position.X, HRP.Position.Y, 0))
            if HRP.Position.X < 0 then
                player.Character.Humanoid.HipHeight = 3.5
                HRP.CFrame *= CFrame.Angles(0, deepCut, 0)
                keypress(0x63)
                setCurrentBall()
                targPosition = Vector3.new(currentBall.Position.Value.X, 0, 0)
                jumpTowardsTarget(player, targPosition)
                keypress(0x20)
                wait(0.2)
                keypress(0x77)
                wait(0.4)
                keyrelease(0x20)
                keyrelease(0x77)
                keyrelease(0x63)
                player.Character.Humanoid.HipHeight = 2
            else
                player.Character.Humanoid.HipHeight = 3.5
                HRP.CFrame *= CFrame.Angles(0, deepCut * -1, 0)
                keypress(0x63)
                setCurrentBall()
                targPosition = Vector3.new(currentBall.Position.Value.X, 0, 0)
                jumpTowardsTarget(player, targPosition)
                keypress(0x20)
                wait(0.2)
                keypress(0x77)
                wait(0.4)
                keyrelease(0x20)
                keyrelease(0x77)
                keyrelease(0x63)
                player.Character.Humanoid.HipHeight = 2
            end
        end
        HRP.Tilt.D = 500
        HRP.Tilt.P = 3000
    end
end)




-- Auto Spike
function ididathing(tempParams)
    -- Spike Distance
    setCurrentBall()
    local longin = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 48 + tonumber(math.abs(HRP.Position.Z)), tempParams)
    local longout = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 45.5 + tonumber(math.abs(HRP.Position.Z)), tempParams)

    local newmidlongin = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 45, tempParams)
    local newmidlongout = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 43, tempParams)

    local midlongin = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 42.5, tempParams)
    local midlongout = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 39.5, tempParams)

    local newmidin = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 38.5, tempParams)
    local newmidout = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 36.5, tempParams)

    local midin = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 35, tempParams)
    local midout = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 32, tempParams)

    local shortmidin2 = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 31.5, tempParams)
    local shortmidout2 = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 29, tempParams)

    local shortmidin1 = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 28, tempParams)
    local shortmidout1 = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 25, tempParams)

    local shortin = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 24, tempParams)
    local shortout = workspace:GetPartBoundsInRadius(Vector3.new(HRP.Position.X, 1, HRP.Position.Z), 19, tempParams)
    local bumpnetNetout = workspace:GetPartBoundsInBox(CFrame.new(0, 0, 0), Vector3.new(48, 5, 2.5), tempParams)
    local netout = workspace:GetPartBoundsInBox(CFrame.new(0, 0, 0), Vector3.new(48, 5, (2 * tonumber(math.abs(HRP.Position.Z))) - 1), tempParams)
    for i, v in pairs(longin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(longout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(newmidlongin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(newmidlongout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(midlongin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(midlongout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(newmidin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(newmidout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(midin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(midout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(shortmidin2) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(shortmidout2) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(shortmidin1) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(shortmidout1) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(shortin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(shortout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(netout) do
        v.BrickColor = BrickColor.new(21)
    end
    if currentBall and currentBall.Position.Value.Z > 0.36 and currentBall.Position.Value.Z < -0.36 then
        for i, v in pairs(bumpnetNetout) do
            v.BrickColor = BrickColor.new(21)
        end
    end
    for i, v in pairs(longin) do
        if v.BrickColor == BrickColor.new(37) then
            table.insert(possibleSpots, v)
            v.Transparency = 0.8
        end
    end

    local tempArray = {}
    local tempPlayerArray = {}
    for i, v in ipairs(possibleSpots) do
        table.insert(tempArray, v)
    end
    for i, v in ipairs(playersArray) do
        table.insert(tempPlayerArray, v)
    end
    local finalArray, finalplayerArray = antiBlock(tempArray, tempPlayerArray)
    finalArray = netBlocked(finalArray)
    --farthestFinder(finalArray, finalplayerArray) -- Find Farthest Part
    farthestPart = nil
    local bestScore = -math.huge
    for _, S in ipairs(finalArray) do
        local s = scoreSpot(S, finalplayerArray, HRP.Position)
        if s > bestScore then
            bestScore, farthestPart = s, S
        end
    end
    --farthestPart.BrickColor = BrickColor.new(1)
    farthestPart.Transparency = 0
    
    -- Tilt Handler
    local tilt
    local pwr13 = false
    if findDistance(farthestPart, player) < 21.5 then
        tilt = true
        pwr13 = true
    elseif findDistance(farthestPart, player) < 25 then
        tilt = true
    elseif findDistance(farthestPart, player) < 29 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 1400
    elseif findDistance(farthestPart, player) < 32 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 1100
    elseif findDistance(farthestPart, player) < 36.5 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 800
    elseif findDistance(farthestPart, player) < 39.5 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 550
    elseif findDistance(farthestPart, player) < 43 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 300
    elseif findDistance(farthestPart, player) < 45 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 150
    end

    -- Spike Inputs
    keypress(0x57)
    keypress(0x41)
    keypress(0x53)
    keypress(0x44)
    keypress(0x43)
    if pwr13 == true then
        keypress(0x51)
        keyrelease(0x51)
        keypress(0x51)
        keyrelease(0x51)
    end
    wait(0.01)
    HRP.CFrame = CFrame.lookAt(HRP.Position, Vector3.new(farthestPart.Position.X, HRP.Position.Y, farthestPart.Position.Z)) -- AIM
    keypress(0x20)  -- JUMP
    wait(0.01)
    keyrelease(0x57)
    keyrelease(0x41)
    keyrelease(0x53)
    keyrelease(0x44)
    keyrelease(0x43)
    pwr13 = false
    player.Character.Humanoid.AutoRotate = false
    if tilt then  -- FORWARD TILT
        keypress(0x57)
        wait(0.05)
        keyrelease(0x57)
    end

    -- Cleanup
    table.clear(possibleSpots)
    keyrelease(0x20)
    player.Character.Humanoid.AutoRotate = true
    for i, v in pairs(longin) do
        v.BrickColor = BrickColor.new(21)
        v.Transparency = 1
    end
    farthestPart.Transparency = 1
    farthestPart = nil
    local farthestDistance = nil
    longin = {}
    longout = {}
    shortin = {}
    shortout = {}
    task.wait(1)
    HRP.Tilt.D = 500
    HRP.Tilt.P = 3000
end


-- Glide AutoSpike
function glideSpike(tempParams)
    setCurrentBall()
    local longin = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 48 + tonumber(math.abs(currentBall.Position.Value.Z)), tempParams)
    local longout = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 45 + tonumber(math.abs(currentBall.Position.Value.Z)), tempParams)

    local newmidlongin = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 45, tempParams)
    local newmidlongout = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 43, tempParams)

    local midlongin = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 42.5, tempParams)
    local midlongout = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 39.5, tempParams)

    local newmidin = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 38.5, tempParams)
    local newmidout = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 36.5, tempParams)

    local midin = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 35, tempParams)
    local midout = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 32, tempParams)

    local shortmidin2 = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 31.5, tempParams)
    local shortmidout2 = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 29, tempParams)

    local shortmidin1 = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 28, tempParams)
    local shortmidout1 = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 25, tempParams)

    local shortin = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 24, tempParams)
    local shortout = workspace:GetPartBoundsInRadius(Vector3.new(currentBall.Position.Value.X, 1, currentBall.Position.Value.Z), 19, tempParams)
    local netout = workspace:GetPartBoundsInBox(CFrame.new(0, 0, 0), Vector3.new(48, 5, (2 * tonumber(math.abs(currentBall.Position.Value.Z))) - 1), tempParams)
    for i, v in pairs(longin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(longout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(newmidlongin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(newmidlongout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(midlongin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(midlongout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(newmidin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(newmidout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(midin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(midout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(shortmidin2) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(shortmidout2) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(shortmidin1) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(shortmidout1) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(shortin) do
        v.BrickColor = BrickColor.new(37)
    end
    for i, v in pairs(shortout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(netout) do
        v.BrickColor = BrickColor.new(21)
    end
    for i, v in pairs(longin) do
        if v.BrickColor == BrickColor.new(37) then
            table.insert(possibleSpots, v)
            v.Transparency = 0.8
        end
    end

    local tempArray = {}
    local tempPlayerArray = {}
    for i, v in ipairs(possibleSpots) do
        table.insert(tempArray, v)
    end
    for i, v in ipairs(playersArray) do
        table.insert(tempPlayerArray, v)
    end
    local finalArray, finalplayerArray = antiBlock2(tempArray, currentBall, tempPlayerArray)
    finalArray = netBlocked(finalArray)
    --farthestFinder(finalArray, finalplayerArray) -- Find Farthest Part
    local bestScore = -math.huge
    for _, S in ipairs(finalArray) do
        local s = scoreSpot(S, finalplayerArray, HRP.Position)
        if s > bestScore then
            bestScore, farthestPart = s, S
        end
    end
    --farthestPart.BrickColor = BrickColor.new(1)
    farthestPart.Transparency = 0
    
    -- Tilt Handler
    local tilt
    local pwr13 = false
    if findDistance2(farthestPart, currentBall) < 21.5 then
        tilt = true
        pwr13 = true
    elseif findDistance2(farthestPart, currentBall) < 25 then
        tilt = true
    elseif findDistance2(farthestPart, currentBall) < 29 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 1400
    elseif findDistance2(farthestPart, currentBall) < 32 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 1100
    elseif findDistance2(farthestPart, currentBall) < 36.5 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 800
    elseif findDistance2(farthestPart, currentBall) < 39.5 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 550
    elseif findDistance2(farthestPart, currentBall) < 43 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 300
    elseif findDistance2(farthestPart, currentBall) < 45 then
        tilt = true
        HRP.Tilt.D = 300
        HRP.Tilt.P = 150
    end

    -- Spike Inputs
    keypress(0x43)
    if pwr13 == true then
        keypress(0x51)
        keyrelease(0x51)
        keypress(0x51)
        keyrelease(0x51)
    end
    wait(0.01)
    --HRP.CFrame = CFrame.lookAt(HRP.Position, Vector3.new(farthestPart.Position.X, HRP.Position.Y, farthestPart.Position.Z)) -- AIM
    local direction = (Vector3.new(farthestPart.Position.X, 0, farthestPart.Position.Z) - (Vector3.new(currentBall.Position.Value.X, 0, currentBall.Position.Value.Z))).unit
    local targPosition = Vector3.new(currentBall.Position.Value.X, HRP.Position.Y, currentBall.Position.Value.Z)
    HRP.CFrame = CFrame.lookAlong(HRP.Position, direction)
    jumpTowardsTarget2(player, targPosition)
    keypress(0x20)  -- JUMP
    wait(0.01)
    
    keyrelease(0x43)
    player.Character.Humanoid.AutoRotate = false
    if tilt then  -- FORWARD TILT
        keypress(0x57)
        wait(0.05)
        keyrelease(0x57)
    end
    pwr13 = false

    -- Cleanup
    table.clear(possibleSpots)
    keyrelease(0x20)
    player.Character.Humanoid.AutoRotate = true
    for i, v in pairs(longin) do
        v.BrickColor = BrickColor.new(21)
        v.Transparency = 1
    end
    farthestPart.Transparency = 1
    farthestPart = nil
    local farthestDistance = nil
    longin = {}
    longout = {}
    shortin = {}
    shortout = {}
    task.wait(1)
    HRP.Tilt.D = 500
    HRP.Tilt.P = 3000
end

--  Anti Net Smash
function netBlocked(spotsArray)
    local originHeight
    local finalArray = {}
    if currentBall.Velocity.Value.Y < 0 and currentBall.Position.Value.Y < 11 then
        originHeight = 13
    elseif currentBall.Velocity.Value.Y > 0 and currentBall.Position.Value.Y < 11 then
        originHeight = 13
    elseif currentBall.Velocity.Value.Y > 0 and currentBall.Position.Value.Y > 11 then
        originHeight = currentBall.Position.Value.Y
    elseif currentBall.Velocity.Value.Y < 0 and currentBall.Position.Value.Y > 11 then
        originHeight = currentBall.Position.Value.Y
    end
    local origin = Vector3.new(HRP.Position.X, originHeight, HRP.Position.Z)
    for _, v in ipairs(spotsArray) do
        local direction = v.Position - origin
        local result = game.Workspace:Raycast(origin, direction, netParams)
        if not result then
            table.insert(finalArray, v)
        else
            v.BrickColor = BrickColor.new(21)
        end
    end
    return finalArray
end



-- Array Handling
do
    playersArray = Players:GetChildren()
end

Players.ChildAdded:Connect(function(v)
    table.insert(playersArray, v)
end)

Players.PlayerRemoving:Connect(function(v)
    local found = table.find(playersArray, v)
    if found then
        table.remove(playersArray, found)
    end
end)





-- Find Distance Between Spot and Player
function findDistance(spot, plr)
    --print(math.sqrt(((plr.Character.HumanoidRootPart.Position.X - spot.Position.X)^2) + ((plr.Character.HumanoidRootPart.Position.Z - spot.Position.Z)^2)))
    return math.sqrt(((plr.Character.HumanoidRootPart.Position.X - spot.Position.X)^2) + ((plr.Character.HumanoidRootPart.Position.Z - spot.Position.Z)^2))
end

function findDistance2(spot, plr)
    --print(math.sqrt(((plr.Character.HumanoidRootPart.Position.X - spot.Position.X)^2) + ((plr.Character.HumanoidRootPart.Position.Z - spot.Position.Z)^2)))
    return math.sqrt(((plr.Position.Value.X - spot.Position.X)^2) + ((plr.Position.Value.Z - spot.Position.Z)^2))
end



-- Find Furthest Spot From Player
function farthestFinder(spods, playas)
    farthestDistance = nil
    for _, v in pairs(spods) do -- for every spot
        local closestDistance = nil -- the closest distance between the closest spot and player
        for _, u in pairs(playas) do
            if u.TeamColor ~= player.TeamColor and u.TeamColor ~= BrickColor.new("White")then
                local currentDistance = findDistance(v, u) -- Finds the current distance between the current spot and current player

                -- If there is no closestDistance yet OR the distance between the current spot and player is smaller than the previous closestDistance
                if closestDistance == nil or currentDistance < closestDistance then
                    closestDistance = currentDistance -- Sets the new smallest distance to a player
                end
            end
        end
        if closestDistance then
            if farthestDistance == nil or closestDistance > farthestDistance then -- if the distance to the closest player is > than the previous farthestDistance
                farthestDistance = closestDistance -- set new farthestDistance
                farthestPart = v -- sets new farthestPart
            end
        end
    end
end




-- Rebound Script
function rebound()
    local rcParams = RaycastParams.new()
    rcParams.FilterDescendantsInstances = {filterTable}
    rcParams.FilterType = Enum.RaycastFilterType.Whitelist
    local origin = Vector3.new(HRP.Position.X, HRP.Position.Y, HRP.Position.Z)
    local direction = HRP.CFrame.LookVector * 15
    local rcResult = workspace:Raycast(origin, direction, rcParams)
    if rcResult then
        keypress(0x78)
        wait(0.001)
        keyrelease(0x78)
    end
end


-- Anti Block 
function isJumping(v)
    -- Get the player's character
    local character = v.Character
    if character then
        -- Get the Humanoid
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            -- Check if the Humanoid is currently jumping
            return humanoid.FloorMaterial == Enum.Material.Air
        end
    end
    return false
end


function findJumpingPlayers()
    local jumpingPlayers = {}
    for _, v in ipairs(Players:GetPlayers()) do
        if v.TeamColor ~= player.TeamColor then
            if isJumping(v) then
                table.insert(jumpingPlayers, v)
            end
        end
    end
    return jumpingPlayers
end

function findIgnoreablePlayers()
    local ignoreablePlayers = {}
    for _, v in ipairs(Players:GetPlayers()) do
        if v.TeamColor ~= player.TeamColor then
            if isJumping(v) then
                if v.Character.HumanoidRootPart.Position.Y < 6.6 and v.Character.HumanoidRootPart.Velocity.Y < 0 then
                    table.insert(ignoreablePlayers, v)
                end
            end
        end
    end
    return ignoreablePlayers
end

--[[function findJumpers()
    local jumpingPlayers = findJumpingPlayers()
    for _, v in ipairs(jumpingPlayers) do
        print(player.Name .. " is jumping.")
    end
end]]--

function calculateArea(x1, z1, x2, z2, x3, z3)
	return math.abs((x1*(z2-z3) + x2*(z3-z1) + x3*(z1-z2)) / 2.0)
end

function isInsideTriangle(x1, z1, x2, z2, x3, z3, x, z)
	-- Calculate the total area of the triangle
	local totalArea = calculateArea(x1, z1, x2, z2, x3, z3)

	-- Calculate the area of three sub-triangles formed by the point and the triangle vertices
	local area1 = calculateArea(x, z, x2, z2, x3, z3)
	local area2 = calculateArea(x1, z1, x, z, x3, z3)
	local area3 = calculateArea(x1, z1, x2, z2, x, z)

	-- If the sum of the areas of the sub-triangles equals the total area, the point is inside the triangle
	return (totalArea == area1 + area2 + area3)
end

function castray(origin, direction)
    --print(walls)
	local rayDirection = CFrame.lookAt(HRP.Position, Vector3.new(direction.Position.X, origin.Y, direction.Position.Z))
    --print(origin, "OG")
    --print(direction.Position, "DP")
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {walls}
	raycastParams.FilterType = Enum.RaycastFilterType.Include
	raycastParams.IgnoreWater = true

	local raycastResult = workspace:Raycast(HRP.Position, rayDirection.LookVector * 600, raycastParams)
    if raycastResult == nil then
        print("ITS NIL FOR SOME REASON")
    else 
        print(raycastResult.Position, "RP")
    end
    return raycastResult.Position
end

function antiBlock(tempArray, tempPlayerArray) -- tempArray = position of possible spots
    local finalArray = {}
    local finalplayerArray = {}
    local jumpingPlayers = findJumpingPlayers()
    local ignoreablePlayers = findIgnoreablePlayers()
    if #jumpingPlayers ~= 0 then 
        for _, v in ipairs(jumpingPlayers) do
            local blockHitboxCF = v.Character.BlockHitbox.CFrame
            local size = v.Character.BlockHitbox.Size

            local directLeft = (blockHitboxCF - blockHitboxCF.RightVector * size.X/2)
            local backLeft = (directLeft - blockHitboxCF.LookVector * size.X/2)
            local frontLeft = (directLeft + blockHitboxCF.LookVector * size.X/2)

            local directRight = (blockHitboxCF + blockHitboxCF.RightVector * size.X/2)
            local backRight = (directRight - blockHitboxCF.LookVector * size.X/2)
            local frontRight = (directRight + blockHitboxCF.LookVector * size.X/2)

            local t1 = HRP.Position
            local t2 = castray(HRP.Position, backLeft)
            local t3 = castray(HRP.Position, frontRight)
            local t4 = castray(HRP.Position, backRight)
            local t5 = castray(HRP.Position, frontLeft)
            local t6
            for _, u in ipairs(tempArray) do
                t6 = u.Position
                --print(t6.. "t6")
                if not isInsideTriangle(t1.X, t1.Z, t2.X, t2.Z, t3.X, t3.Z, t6.X, t6.Z) and not isInsideTriangle(t1.X, t1.Z, t4.X, t4.Z, t5.X, t5.Z, t6.X, t6.Z) then
                    table.insert(finalArray, u)
                else
                    u.BrickColor = BrickColor.new(21)
                end
            end
            for i, u in ipairs(tempPlayerArray) do
                if u ~= v then
                    table.insert(finalplayerArray, u)
                end
            end
        end
        for i = #finalplayerArray, 1, -1 do
            local playerToCheck = finalplayerArray[i]
            if table.find(ignoreablePlayers, playerToCheck) then
                table.remove(finalplayerArray, i)
            end
        end
        return finalArray, finalplayerArray
    else
        return tempArray, tempPlayerArray
    end
end




function castray2(origin, direction)
    --print(walls)
	local rayDirection = CFrame.lookAt(origin, Vector3.new(direction.Position.X, origin.Y, direction.Position.Z))
    --print(origin, "OG")
    --print(direction.Position, "DP")
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {walls}
	raycastParams.FilterType = Enum.RaycastFilterType.Include
	raycastParams.IgnoreWater = true

	local raycastResult = workspace:Raycast(origin, rayDirection.LookVector * 600, raycastParams)
    if raycastResult == nil then
        print("ITS NIL FOR SOME REASON")
    else 
        print(raycastResult.Position, "RP")
    end
    return raycastResult.Position
end

function antiBlock2(tempArray, origin, tempPlayerArray) -- tempArray = position of possible spots
    local finalArray = {}
    local finalplayerArray = {}
    local jumpingPlayers = findJumpingPlayers()
    local ignoreablePlayers = findIgnoreablePlayers()
    if #jumpingPlayers ~= 0 then 
        for _, v in ipairs(jumpingPlayers) do
            local blockHitboxCF = v.Character.BlockHitbox.CFrame
            local size = v.Character.BlockHitbox.Size
            local directLeft = (blockHitboxCF - blockHitboxCF.RightVector * size.X/2)
            local backLeft = (directLeft - blockHitboxCF.LookVector * size.X/2)
            local frontLeft = (directLeft + blockHitboxCF.LookVector * size.X/2)

            local directRight = (blockHitboxCF + blockHitboxCF.RightVector * size.X/2)
            local backRight = (directRight - blockHitboxCF.LookVector * size.X/2)
            local frontRight = (directRight + blockHitboxCF.LookVector * size.X/2)
            local t1 = origin.Position.Value
            local t2 = castray2(origin.Position.Value, backLeft)
            local t3 = castray2(origin.Position.Value, frontRight)
            local t4 = castray2(origin.Position.Value, backRight)
            local t5 = castray2(origin.Position.Value, frontLeft)
            local t6
            for _, u in ipairs(tempArray) do
                t6 = u.Position
                --print(t6.. "t6")
                if not isInsideTriangle(t1.X, t1.Z, t2.X, t2.Z, t3.X, t3.Z, t6.X, t6.Z) and not isInsideTriangle(t1.X, t1.Z, t4.X, t4.Z, t5.X, t5.Z, t6.X, t6.Z) then
                    table.insert(finalArray, u)
                else
                    u.BrickColor = BrickColor.new(21)
                end
            end
            for i, u in ipairs(tempPlayerArray) do
                if u ~= v then
                    table.insert(finalplayerArray, u)
                end
            end
        end
        for i = #finalplayerArray, 1, -1 do
            local playerToCheck = finalplayerArray[i]
            if table.find(ignoreablePlayers, playerToCheck) then
                table.remove(finalplayerArray, i)
            end
        end
	return finalArray, finalplayerArray
    else
        return tempArray, tempPlayerArray
    end
end



player.Character:WaitForChild("TopHitbox").Transparency = 0.5
